{
	"info": {
		"_postman_id": "a0d2170d-5282-4e2e-9a86-190cb23dfa88",
		"name": "Rosetta Java | Data endpoints",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "5364165"
	},
	"item": [
		{
			"name": "/search/transactions",
			"item": [
				{
					"name": "sanity checks",
					"item": [
						{
							"name": "default pagination",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const res = pm.response.json();",
											"const transactions = res.transactions || [];",
											"",
											"const testBlueprint = {",
											"    expected: {",
											"        counts: {",
											"            defaultPageLimit: 100",
											"        }",
											"    }",
											"};",
											"",
											"pm.test(\"Response has exactly 100 transactions by default\", () => {",
											"    const { defaultPageLimit } = testBlueprint.expected.counts;",
											"",
											"    // list length",
											"    pm.expect(transactions, \"Must respect default limit\")",
											"        .to.have.lengthOf(defaultPageLimit);",
											"",
											"});",
											"",
											"pm.test(\"Search results should probably have more transactions than the default limit\", () => {",
											"    const { defaultPageLimit } = testBlueprint.expected.counts;",
											"",
											"    // total_count > returned items (because here we know there is more then defaultPageLimit txs)",
											"    pm.expect(res.total_count, \"`total_count` must be > #returned\")",
											"        .to.be.gt(defaultPageLimit);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) missing network identifier",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Missing network_identifier returns appropriate error\", () => {",
											"    const res = pm.response.json();",
											"",
											"    pm.expect(pm.response.code, \"Should return error status code\")",
											"        .to.be.at.least(400);",
											"",
											"    const errorMessage = res.details?.message || res.message || \"\";",
											"    pm.expect(/network[_a-z]*identifier/i.test(errorMessage), \"Error message should indicate missing network_identifier or networkIdentifier\").to.be.true;",
											"});",
											"",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"account_identifier\": {\n        \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) invalid network",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Invalid network returns appropriate error\", () => {",
											"    const res = pm.response.json();",
											"    pm.expect(pm.response.code, \"Should return error status code\")",
											"        .to.be.gte(400);",
											"    pm.expect(res.code, \"Error code should be 4002\").to.eql(4002);",
											"    pm.expect(res.message, \"Error message should indicate network not found\").to.eql(\"Network not found\");",
											"    pm.expect(res.retriable, \"`retriable` must be false\").to.be.false;",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"invalid_network\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Validates the endpointâ€™s basic behavior: correct responses with no filters, invalid inputs, and proper error codes."
				},
				{
					"name": "limit",
					"item": [
						{
							"name": "limit 0",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"transactions should be an empty array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData.transactions).to.be.an(\"array\").that.is.empty;",
											"});",
											"",
											"pm.test(\"total_count should be greater than 0\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData.total_count).to.be.above(0);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": 0\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "limit 1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"pm.test(\"Operations index are sequential\", () => {",
											"    const res = pm.response.json();",
											"    const ops = res.transactions[0].transaction.operations.map(o => o.operation_identifier.index);",
											"    for (let i = 0; i < ops.length; i++) {",
											"        pm.expect(ops[i]).to.eql(i);",
											"    }",
											"});",
											"",
											"const transactions = pm.response.json().transactions; // Defined transactions here",
											"pm.test(\"Transactions have unique hashes\", () => {",
											"    const hashes = transactions.map(t => t.transaction.transaction_identifier.hash);",
											"    const uniqueHashes = [...new Set(hashes)];",
											"    pm.expect(uniqueHashes.length, \"Duplicate transaction hashes found\")",
											"        .to.equal(hashes.length);",
											"});",
											"pm.test(\"Block indexes are non-negative\", () => {",
											"    transactions.forEach(t => {",
											"        pm.expect(t.block_identifier.index).to.be.at.least(0);",
											"    });",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": 1\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "limit 9",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"pm.test(\"Operations index are sequential in all transactions\", () => {",
											"    const res = pm.response.json();",
											"",
											"    res.transactions.forEach((tx, txIndex) => {",
											"        const ops = tx.transaction.operations.map(o => o.operation_identifier.index);",
											"",
											"        for (let i = 0; i < ops.length; i++) {",
											"            pm.expect(ops[i], `Transaction ${txIndex} operation index mismatch at position ${i}`)",
											"              .to.eql(i);",
											"        }",
											"    });",
											"});",
											"",
											"const transactions = pm.response.json().transactions; // Defined transactions here",
											"pm.test(\"Transactions have unique hashes\", () => {",
											"    const hashes = transactions.map(t => t.transaction.transaction_identifier.hash);",
											"    const uniqueHashes = [...new Set(hashes)];",
											"    pm.expect(uniqueHashes.length, \"Duplicate transaction hashes found\")",
											"        .to.equal(hashes.length);",
											"});",
											"pm.test(\"Block indexes are non-negative\", () => {",
											"    transactions.forEach(t => {",
											"        pm.expect(t.block_identifier.index).to.be.at.least(0);",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": 9\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "limit 20",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"pm.test(\"Operations index are sequential in all transactions\", () => {",
											"    const res = pm.response.json();",
											"",
											"    res.transactions.forEach((tx, txIndex) => {",
											"        const ops = tx.transaction.operations.map(o => o.operation_identifier.index);",
											"",
											"        for (let i = 0; i < ops.length; i++) {",
											"            pm.expect(ops[i], `Transaction ${txIndex} operation index mismatch at position ${i}`)",
											"              .to.eql(i);",
											"        }",
											"    });",
											"});",
											"const transactions = pm.response.json().transactions; // Defined transactions here",
											"pm.test(\"Transactions have unique hashes\", () => {",
											"    const hashes = transactions.map(t => t.transaction.transaction_identifier.hash);",
											"    const uniqueHashes = [...new Set(hashes)];",
											"    pm.expect(uniqueHashes.length, \"Duplicate transaction hashes found\")",
											"        .to.equal(hashes.length);",
											"});",
											"pm.test(\"Block indexes are non-negative\", () => {",
											"    transactions.forEach(t => {",
											"        pm.expect(t.block_identifier.index).to.be.at.least(0);",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": 20\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "limit 100",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"pm.test(\"Operations index are sequential in all transactions\", () => {",
											"    const res = pm.response.json();",
											"",
											"    res.transactions.forEach((tx, txIndex) => {",
											"        const ops = tx.transaction.operations.map(o => o.operation_identifier.index);",
											"",
											"        for (let i = 0; i < ops.length; i++) {",
											"            pm.expect(ops[i], `Transaction ${txIndex} operation index mismatch at position ${i}`)",
											"              .to.eql(i);",
											"        }",
											"    });",
											"});",
											"const transactions = pm.response.json().transactions; // Defined transactions here",
											"pm.test(\"Transactions have unique hashes\", () => {",
											"    const hashes = transactions.map(t => t.transaction.transaction_identifier.hash);",
											"    const uniqueHashes = [...new Set(hashes)];",
											"    pm.expect(uniqueHashes.length, \"Duplicate transaction hashes found\")",
											"        .to.equal(hashes.length);",
											"});",
											"pm.test(\"Block indexes are non-negative\", () => {",
											"    transactions.forEach(t => {",
											"        pm.expect(t.block_identifier.index).to.be.at.least(0);",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": 100\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) limit 200",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should NOT be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(500);",
											"});",
											"const res = pm.response.json();",
											"pm.test(\"Error code is 5053\", () => {",
											"    pm.expect(res.code).to.eql(5053);",
											"});",
											"pm.test(\"Requested limit size exceeds maximum allowed size 100\", () => {",
											"    pm.expect(res.message).to.eql(\"Invalid limit size\");",
											"});",
											"",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": 200\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) limit -1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// The folder-level script already checks the status code and error schema.",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should NOT be successful\", () => {",
											"    pm.expect(pm.response.code).to.not.eql(200);",
											"});",
											"",
											"// This test just adds a check for the specific error message content.",
											"pm.test(\"Error message is meaningful and context-specific\", () => {",
											"    const res = pm.response.json();",
											"",
											"    pm.expect(res.details.message).to.satisfy((msg) =>",
											"        msg.includes(\"limit must be greater than or equal to 0\") || msg.includes(\"body.limit should be >= 0\")",
											"    );",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"limit\": -1\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Focuses on how the endpoint respects the limit parameter, ensuring correct record counts and behavior at min/max boundaries.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"const limit = body.limit;",
									"const testBlueprint = {",
									"    expected: {",
									"        counts: {",
									"            limit: body.limit",
									"        }",
									"    }",
									"};",
									"",
									"// list length should have the same length as the limit in the request body",
									"const testName =",
									"    \"ðŸ“ limit | Response should probably have exactly \" +",
									"    testBlueprint.expected.counts.limit +",
									"    (testBlueprint.expected.counts.limit === 1 ? \" transaction\" : \" transactions\") +",
									"    \" in the response body\";",
									"",
									"pm.test(testName, () => {",
									"    if (limit > 100) {",
									"        // Skip length assertion, only check for correct error response",
									"        pm.expect(res.code).to.eql(5053);",
									"        pm.expect(res.message).to.include(\"Invalid limit size\");",
									"    } else {",
									"        // Original assertion logic",
									"        pm.expect(transactions)",
									"            .to.have.lengthOf.at.least(testBlueprint.expected.counts.limit);",
									"    }",
									"});"
								]
							}
						}
					]
				},
				{
					"name": "offset",
					"item": [
						{
							"name": "offset 0",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"offset\": 0\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "offset 1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"offset\": 1\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "offset 9",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"offset\": 9\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "offset 20",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"offset\": 20\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "offset 100",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"offset\": 100\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) offset -1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// The folder-level script already checks the status code and error schema.",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should NOT be successful\", () => {",
											"    pm.expect(pm.response.code).to.not.eql(200);",
											"});",
											"",
											"// This test just adds a check for the specific error message content.",
											"pm.test(\"Error message is meaningful and context-specific\", () => {",
											"    const res = pm.response.json();",
											"",
											"    pm.expect(res.details.message).to.satisfy((msg) =>",
											"        msg.includes(\"offset must be greater than or equal to 0\") || msg.includes(\"body.offset should be >= 0\")",
											"    );",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"offset\": -1\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Tests pagination via offset, including empty pages, exact boundaries, and sequences of requests.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"const offset = body.offset || 0;",
									"const defaultPageLimit = 100;",
									"",
									"",
									"// Edge case: Empty results when offset >= total_count",
									"if (res.total_count <= offset && offset > 0) {",
									"    pm.test(`ðŸ“ offset | Offset ${offset} >= total_count returns empty`, () => {",
									"        pm.expect(transactions, \"Should return empty array\")",
									"            .to.have.lengthOf(0);",
									"        pm.expect(res, \"Should not have next_offset\")",
									"            .to.not.have.property(\"next_offset\");",
									"    });",
									"}",
									"",
									"// Pagination consistency check (respects limit)",
									"pm.test(`ðŸ“ offset | Response respects limit with offset ${offset}`, () => {",
									"    const limit = body.limit || defaultPageLimit;",
									"    pm.expect(transactions, `should return at most ${limit} transactions`)",
									"        .to.have.length.at.most(limit);",
									"});"
								]
							}
						}
					]
				},
				{
					"name": "transaction identifier",
					"item": [
						{
							"name": "valid transaction hash",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"",
											"const testBlueprint = {",
											"    expected: {",
											"        counts: {",
											"            transactions: 1",
											"        },",
											"        values: {",
											"            hash: \"d8d35a05f3f31e955b57a78b8d39410332bd21bd8a61f8aca670916b96a0200f\",",
											"            block_index: 3663529",
											"        }",
											"    }",
											"};",
											"",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns exactly 1 transaction for valid hash\", () => {",
											"    pm.expect(transactions, \"Should return exactly 1 transaction\")",
											"        .to.have.lengthOf(testBlueprint.expected.counts.transactions);",
											"    ",
											"    pm.expect(transactions[0].transaction.transaction_identifier.hash, \"Hash should match requested\")",
											"        .to.eql(testBlueprint.expected.values.hash);",
											"    ",
											"    pm.expect(transactions[0].block_identifier.index, \"Block index should match expected\")",
											"        .to.eql(testBlueprint.expected.values.block_index);",
											"});",
											"",
											"pm.test(\"Transaction structure is complete\", () => {",
											"    const tx = transactions[0];",
											"    ",
											"    pm.expect(tx.transaction.operations, \"Operations should be present\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(tx.transaction.operations.length, \"Should have expected number of operations\")",
											"        .to.eql(12); // 9 inputs + 3 outputs",
											"    ",
											"    // Verify operation types",
											"    const inputs = tx.transaction.operations.filter(op => op.type === 'input');",
											"    const outputs = tx.transaction.operations.filter(op => op.type === 'output');",
											"    ",
											"    pm.expect(inputs.length, \"Should have 9 inputs\").to.eql(9);",
											"    pm.expect(outputs.length, \"Should have 3 outputs\").to.eql(3);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"transaction_identifier\": {\n        \"hash\": \"d8d35a05f3f31e955b57a78b8d39410332bd21bd8a61f8aca670916b96a0200f\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "non-existent transaction hash",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"",
											"const testBlueprint = {",
											"    expected: {",
											"        counts: {",
											"            transactions: 0,",
											"            total_count: 0",
											"        },",
											"        values: {",
											"            status_code: 200",
											"        }",
											"    }",
											"};",
											"",
											"pm.test(\"Returns 200 OK for non-existent hash\", () => {",
											"    pm.response.to.have.status(testBlueprint.expected.values.status_code);",
											"});",
											"",
											"pm.test(\"Empty result for non-existent hash\", () => {",
											"    pm.expect(responseJson.transactions, \"Should return empty array\")",
											"        .to.be.an(\"array\").and.have.lengthOf(0);",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be 0\")",
											"        .to.eql(testBlueprint.expected.counts.total_count);",
											"    ",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"transaction_identifier\": {\n        \"hash\": \"a0b0847b3c369333bc7a8346a7136e5d842075246288fb133b5501db\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "invalid transaction hash format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"",
											"const testBlueprint = {",
											"    expected: {",
											"        counts: {",
											"            transactions: 0,",
											"            total_count: 0",
											"        },",
											"        values: {",
											"            status_code: 200",
											"        }",
											"    }",
											"};",
											"",
											"pm.test(\"Returns 200 OK for invalid hash\", () => {",
											"    pm.response.to.have.status(testBlueprint.expected.values.status_code);",
											"});",
											"",
											"pm.test(\"Empty result for invalid hash\", () => {",
											"    pm.expect(responseJson.transactions, \"Should return empty array\")",
											"        .to.be.an(\"array\").and.have.lengthOf(0);",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be 0\")",
											"        .to.eql(testBlueprint.expected.counts.total_count);",
											"    ",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"transaction_identifier\": {\n        \"hash\": \"INVALID_HASH\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "valid payment address - shelley base using address field - large utxos",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns transactions for payment address\", () => {",
											"    pm.expect(transactions, \"Should return transactions for payment address\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be > 0\")",
											"        .to.be.gt(0);",
											"});",
											"",
											"if (body.account_identifier && body.account_identifier.address) {",
											"    pm.test(\"All transactions involve the requested payment address\", () => {",
											"        pm.expect(transactions, \"Should return transactions for payment address\")",
											"            .to.be.an(\"array\").and.not.be.empty;",
											"",
											"        const requestedAddress = body.account_identifier.address;",
											"",
											"        transactions.forEach((tx, txIndex) => {",
											"            const operations = tx.transaction.operations;",
											"            const addressFound = operations.some(op =>",
											"                op.account && op.account.address === requestedAddress",
											"            );",
											"",
											"            pm.expect(addressFound, `Transaction ${txIndex} should involve the requested address`)",
											"                .to.be.true;",
											"        });",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"address\": \"addr_test1wqd2qdzhh3x280q6erdksyku6k3eknrqsmrpkjnn6hsvjegk9gghn\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Verifies that querying by one or more transaction hashes returns the expected results, including not-found cases.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"if (pm.response.code === 200) {",
									"    if (res.total_count > 0){",
									"        pm.test(\"ðŸ“ transaction_identifier | Response contains valid transaction identifiers\", () => {",
									"            transactions.forEach((tx, index) => {",
									"                pm.expect(tx.transaction.transaction_identifier.hash, `Transaction ${index} should have valid hash`)",
									"                    .to.be.a(\"string\").and.not.be.empty;",
									"                ",
									"                pm.expect(tx.transaction.transaction_identifier.hash, `Transaction ${index} hash should be hex format`)",
									"                    .to.match(/^[a-fA-F0-9]+$/);",
									"                ",
									"                pm.expect(tx.transaction.transaction_identifier.hash, `Transaction ${index} hash should be 64 characters`)",
									"                    .to.have.lengthOf(64);",
									"            });",
									"        });",
									"    }",
									"",
									"    // Verify each transaction has the requested hash (if searching by specific hash)",
									"    if (body.transaction_identifier && body.transaction_identifier.hash && transactions.length > 0) {",
									"        pm.test(\"ðŸ“ transaction_identifier | All returned transactions match requested hash\", () => {",
									"            const requestedHash = body.transaction_identifier.hash;",
									"",
									"            transactions.forEach((tx, index) => {",
									"                pm.expect(tx.transaction.transaction_identifier.hash, `Transaction ${index} should match requested hash`)",
									"                    .to.eql(requestedHash);",
									"            });",
									"        });",
									"    }",
									"} else {",
									"    pm.test(\"ðŸ“ transaction_identifier | Error response structure is valid\", () => {",
									"        pm.expect(res.code, \"Should have error code\").to.exist;",
									"        pm.expect(res.message, \"Should have error message\").to.exist;",
									"        pm.expect(res.retriable, \"Should have retriable field\").to.be.a(\"boolean\");",
									"    });",
									"}"
								]
							}
						}
					]
				},
				{
					"name": "account identifier",
					"item": [
						{
							"name": "valid payment address - shelley base",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns transactions for payment address\", () => {",
											"    pm.expect(transactions, \"Should return transactions for payment address\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be > 0\")",
											"        .to.be.gt(0);",
											"});",
											"",
											"if (body.account_identifier && body.account_identifier.address) {",
											"    pm.test(\"All transactions involve the requested payment address\", () => {",
											"        pm.expect(transactions, \"Should return transactions for payment address\")",
											"            .to.be.an(\"array\").and.not.be.empty;",
											"",
											"        const requestedAddress = body.account_identifier.address;",
											"",
											"        transactions.forEach((tx, txIndex) => {",
											"            const operations = tx.transaction.operations;",
											"            const addressFound = operations.some(op =>",
											"                op.account && op.account.address === requestedAddress",
											"            );",
											"",
											"            pm.expect(addressFound, `Transaction ${txIndex} should involve the requested address`)",
											"                .to.be.true;",
											"        });",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "valid payment address - shelley base using address field",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns transactions for payment address\", () => {",
											"    pm.expect(transactions, \"Should return transactions for payment address\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be > 0\")",
											"        .to.be.gt(0);",
											"});",
											"",
											"if (body.account_identifier && body.account_identifier.address) {",
											"    pm.test(\"All transactions involve the requested payment address\", () => {",
											"        pm.expect(transactions, \"Should return transactions for payment address\")",
											"            .to.be.an(\"array\").and.not.be.empty;",
											"",
											"        const requestedAddress = body.account_identifier.address;",
											"",
											"        transactions.forEach((tx, txIndex) => {",
											"            const operations = tx.transaction.operations;",
											"            const addressFound = operations.some(op =>",
											"                op.account && op.account.address === requestedAddress",
											"            );",
											"",
											"            pm.expect(addressFound, `Transaction ${txIndex} should involve the requested address`)",
											"                .to.be.true;",
											"        });",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "valid payment address - shelley enterprise",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns transactions for enterprise address\", () => {",
											"    pm.expect(transactions, \"Should return transactions for payment address\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be > 0\")",
											"        .to.be.gt(0);",
											"});",
											"",
											"if (body.account_identifier && body.account_identifier.address) {",
											"    pm.test(\"All transactions involve the requested enterprise address\", () => {",
											"        pm.expect(transactions, \"Should return transactions for enterprise address\")",
											"            .to.be.an(\"array\").and.not.be.empty;",
											"",
											"        const requestedAddress = body.account_identifier.address;",
											"",
											"        transactions.forEach((tx, txIndex) => {",
											"            const operations = tx.transaction.operations;",
											"            const addressFound = operations.some(op =>",
											"                op.account && op.account.address === requestedAddress",
											"            );",
											"",
											"            pm.expect(addressFound, `Transaction ${txIndex} should involve the requested address`)",
											"                .to.be.true;",
											"        });",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"addr_test1vqnku6rsllyln4fa5s4tlv5ujx0y6kvu4mzzfh5jaht8nfq8584jf\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "valid payment address - byron",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns transactions for payment address\", () => {",
											"    pm.expect(transactions, \"Should return transactions for payment address\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be > 0\")",
											"        .to.be.gt(0);",
											"});",
											"",
											"if (body.account_identifier && body.account_identifier.address) {",
											"    pm.test(\"All transactions involve the requested payment address\", () => {",
											"        pm.expect(transactions, \"Should return transactions for payment address\")",
											"            .to.be.an(\"array\").and.not.be.empty;",
											"",
											"        const requestedAddress = body.account_identifier.address;",
											"",
											"        transactions.forEach((tx, txIndex) => {",
											"            const operations = tx.transaction.operations;",
											"            const addressFound = operations.some(op =>",
											"                op.account && op.account.address === requestedAddress",
											"            );",
											"",
											"            pm.expect(addressFound, `Transaction ${txIndex} should involve the requested address`)",
											"                .to.be.true;",
											"        });",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"37btjrVyb4KEB2STADSsj3MYSAdj52X5FrFWpw2r7Wmj2GDzXjFRsHWuZqrw7zSkwopv8Ci3VWeg6bisU9dgJxW5hb2MZYeduNKbQJrqz3zVBsu9nT\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "[future feature] valid stake address",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"const skipTest = true;",
											"",
											"const testBlueprint = {",
											"    expected: {",
											"        expectedOperationTypes: [\"withdrawal\", \"stakeDelegation\", \"stakeKeyRegistration\", \"stakeKeyDeregistration\"]",
											"    }",
											"};",
											"",
											"(skipTest ? pm.test.skip : pm.test)(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"(skipTest ? pm.test.skip : pm.test)(\"Returns transactions for stake address\", () => {",
											"    pm.expect(transactions, \"Should return transactions for stake address\")",
											"        .to.be.an(\"array\").and.not.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be > 0\")",
											"        .to.be.gt(0);",
											"});",
											"",
											"if (body.account_identifier && body.account_identifier.address) {",
											"    (skipTest ? pm.test.skip : pm.test)(\"All transactions involve the requested stake address\", () => {",
											"        pm.expect(transactions, \"Should return transactions for stake address\")",
											"            .to.be.an(\"array\").and.not.be.empty;",
											"",
											"        const requestedAddress = body.account_identifier.address;",
											"",
											"        transactions.forEach((tx, txIndex) => {",
											"            const operations = tx.transaction.operations;",
											"            const addressFound = operations.some(op => ",
											"                op.account && op.account.address === requestedAddress",
											"            );",
											"            ",
											"            pm.expect(addressFound, `Transaction ${txIndex} should involve the requested address`)",
											"                .to.be.true;",
											"        });",
											"    });",
											"}",
											"",
											"(skipTest ? pm.test.skip : pm.test)(\"Operations have correct types for stake address\", () => {",
											"    transactions.forEach((tx, txIndex) => {",
											"        const operations = tx.transaction.operations;",
											"        const stakeOps = operations.filter(op => ",
											"            testBlueprint.expected.expectedOperationTypes.includes(op.type)",
											"        );",
											"        ",
											"        pm.expect(stakeOps.length, `Transaction ${txIndex} should have stake-related operations`)",
											"            .to.be.gt(0);",
											"    });",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"stake_test1uq7jxnqdcs2lxgu2tl2s3zna4hlsm8p0ud82pdr0cszsepqgprukn\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "invalid account identifier",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions;",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns no transactions\", () => {",
											"    pm.expect(transactions, \"Should returnno transactions for payment address\")",
											"        .to.be.an(\"array\").and.be.empty;",
											"    ",
											"    pm.expect(responseJson.total_count, \"total_count should be == 0\")",
											"        .to.be.eq(0);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"INVALID_ADDRESS\"\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Ensures the endpoint filters correctly by various types of Cardano addresses (payment, enterprise, stake, Byron).",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"if (pm.response.code != 200) {",
									"    pm.test(\"ðŸ“ account_identifier | Error response structure is valid\", () => {",
									"        pm.expect(res.code, \"Should have error code\").to.exist;",
									"        pm.expect(res.message, \"Should have error message\").to.exist;",
									"        pm.expect(res.retriable, \"Should have retriable field\").to.be.a(\"boolean\");",
									"    });",
									"}"
								]
							}
						}
					]
				},
				{
					"name": "max block",
					"item": [
						{
							"name": "max block 748",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"max_block\": 748\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "max block 749",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"max_block\": 749\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "max block 175000",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"max_block\": 175000\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "max block 180000",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"max_block\": 180000\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "max block 185000",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"max_block\": 185000\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "base shelley address with 6 txs at block 3665905",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns 6 transactions at block 3665905\", () => {",
											"    pm.expect(transactions.length).to.equal(6);",
											"    pm.expect(responseJson.total_count).to.equal(6);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"addr_test1qpa0tqf5hwvhl0mvkexrdxrhgg2ftppn7pjfnfz0es2l9g3aydxqm3q47v3c5h74pz98mt0lpkwzlc6w5z6xl3q9pjzqqklmmp\"\n    },\n    \"max_block\": 3665905\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "base shelley address with 1 tx at block 3381969",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns 1 transaction at block 3381969\", () => {",
											"    pm.expect(transactions.length).to.equal(1);",
											"    pm.expect(responseJson.total_count).to.equal(1);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"addr_test1qpa0tqf5hwvhl0mvkexrdxrhgg2ftppn7pjfnfz0es2l9g3aydxqm3q47v3c5h74pz98mt0lpkwzlc6w5z6xl3q9pjzqqklmmp\"\n    },\n    \"max_block\": 3381969\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "base shelley address with 0 tx at block 3381968",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											"",
											"pm.test(\"Returns no transaction at block 3381968\", () => {",
											"    pm.expect(transactions).to.be.empty;",
											"    pm.expect(responseJson.total_count).to.equal(0);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"account_identifier\": {\n        \"address\": \"addr_test1qpa0tqf5hwvhl0mvkexrdxrhgg2ftppn7pjfnfz0es2l9g3aydxqm3q47v3c5h74pz98mt0lpkwzlc6w5z6xl3q9pjzqqklmmp\"\n    },\n    \"max_block\": 3381968\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) invalid max block",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Invalid block index returns specific error\", () => {",
											"    const res = pm.response.json();",
											"    ",
											"    pm.expect(pm.response.code, \"Should return error status code\")",
											"        .to.be.gte(400);",
											"    ",
											"    pm.expect(res.code, \"Should have specific error code\")",
											"        .to.eql(5042);",
											"    ",
											"    pm.expect(res.message, \"Should have meaningful error message\")",
											"        .to.include(\"Invalid block index\");",
											"    ",
											"    pm.expect(res.retriable, \"Should indicate as retriable\")",
											"        .to.be.a(\"boolean\").and.to.be.true",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"max_block\": -10\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Checks that specifying a maximum block height properly restricts the returned transactions.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"if (pm.response.code === 200 && body.max_block !== undefined && transactions.length > 0) {",
									"    pm.test(\"ðŸ“ max_block | All transactions are from blocks <= max_block\", () => {",
									"        const maxBlock = body.max_block;",
									"",
									"        transactions.forEach((tx, index) => {",
									"            pm.expect(tx.block_identifier.index, `Transaction ${index} should be from block <= ${maxBlock}`)",
									"                .to.be.lte(maxBlock);",
									"        });",
									"    });",
									"}"
								]
							}
						}
					]
				},
				{
					"name": "status filtering",
					"item": [
						{
							"name": "status invalid",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"status\": \"invalid\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "status success",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"status\": \"success\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "success true",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"success\": \"true\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "success false",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// ensure response is successful",
											"pm.test(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"success\": \"false\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) status UNKNOWN_STATUS",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Invalid operation status returns specific error\", () => {",
											"    const res = pm.response.json();",
											"    ",
											"    pm.expect(pm.response.code, \"Should return error status code\")",
											"        .to.be.gte(400);",
											"    ",
											"    pm.expect(res.code, \"Should have specific error code\")",
											"        .to.eql(5013);",
											"    ",
											"    pm.expect(res.message, \"Should have meaningful error message\")",
											"        .to.include(\"Invalid operation status\");",
											"    ",
											"    pm.expect(res.retriable, \"Should indicate as not retriable\")",
											"        .to.be.a(\"boolean\").and.to.be.false",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"status\": \"UNKNOWN_STATUS\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Tests that the endpoint correctly filters operations by status (e.g., success/failure) and handles invalid statuses gracefully.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"if (pm.response.code === 200) {",
									"    if (body.status && transactions.length > 0) {",
									"        pm.test(\"ðŸ“ status filtering | All transactions have the requested status\", () => {",
									"",
									"            const requestedStatus = body.status;",
									"",
									"            transactions.forEach((tx, index) => {",
									"                const operationStatuses = tx.transaction.operations.map(op => op.status);",
									"                const hasRequestedStatus = operationStatuses.includes(requestedStatus);",
									"                pm.expect(hasRequestedStatus, `Transaction ${index} should have at least one operation with status: ${requestedStatus}`).to.be.true;",
									"            });",
									"",
									"        });",
									"    }",
									"    if (body.success !== undefined && transactions.length > 0) {",
									"        pm.test(\"ðŸ“ status filtering | All transactions have the requested success flag\", () => {",
									"            const requestedSuccess = body.success === true || body.success === \"true\";",
									"            const expectedStatus = requestedSuccess ? \"success\" : \"invalid\";",
									"",
									"            transactions.forEach((tx, index) => {",
									"                const operationStatuses = tx.transaction.operations.map(op => op.status);",
									"                pm.expect(operationStatuses.includes(expectedStatus), `Transaction ${index} should have at least one operation with status: ${expectedStatus}`).to.be.true;",
									"            });",
									"        });",
									"    };",
									"}"
								]
							}
						}
					]
				},
				{
					"name": "operation type filtering",
					"item": [
						{
							"name": "withdrawal",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"withdrawal\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "stakeKeyRegistration",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"stakeKeyRegistration\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "stakeKeyDeregistration",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"stakeKeyDeregistration\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "stakeDelegation",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"stakeDelegation\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "poolRetirement",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"poolRetirement\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "poolRegistration",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"poolRegistration\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "dRepVoteDelegation",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"dRepVoteDelegation\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "poolGovernanceVote",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip from this test:",
											"pm.test.skip(\"Response should be successful\", () => {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"poolGovernanceVote\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) invalid operation type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test currently handled by folder-level _tests.js since operation type filtering is not implemented",
											"// All operation type requests (valid or invalid) return the same \"not supported\" error",
											"",
											"// When feature is implemented, remove .skip to validate invalid types are properly rejected:",
											"pm.test.skip(\"Invalid operation type returns specific error\", () => {",
											"    const res = pm.response.json();",
											"    ",
											"    pm.expect(pm.response.code, \"Should return error status code\")",
											"        .to.be.gte(400);",
											"    ",
											"    pm.expect(res.code, \"Should have specific error code\")",
											"        .to.eql(4019);",
											"    ",
											"    pm.expect(res.message, \"Should have meaningful error message\")",
											"        .to.include(\"Provided operation type is invalid\");",
											"    ",
											"    pm.expect(res.retriable, \"Should indicate as not retriable\")",
											"        .to.be.a(\"boolean\").and.to.be.false;",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"type\": \"INVALID_OPERATION_TYPE\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Verifies correct behavior when filtering by one or more operation.type values (e.g., inputs, outputs, staking).",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"// TEMPORARILY NEGATIVE TEST - Operation type filtering feature not yet implemented",
									"if (body.type) {",
									"    pm.test(\"ðŸ“ operation type filtering | [TEMP NEGATIVE] Feature not implemented - expects error\", () => {",
									"        pm.expect(pm.response.code, \"Should return error status code\")",
									"            .to.be.gte(400);",
									"        ",
									"        pm.expect(res.code, \"Should have specific error code\")",
									"            .to.eql(5058);",
									"        ",
									"        pm.expect(res.message, \"Should have meaningful error message\")",
									"            .to.include(\"Operation type filtering is not currently supported\");",
									"        ",
									"        pm.expect(res.retriable, \"Should indicate as not retriable\")",
									"            .to.be.a(\"boolean\").and.to.be.false;",
									"    });",
									"}",
									"",
									"// Original test - to be activated when feature is implemented",
									"if (pm.response.code === 200 && body.type && transactions.length > 0) {",
									"    pm.test.skip(\"ðŸ“ operation type filtering | All transactions contain the requested operation type\", () => {",
									"        const requestedType = body.type;",
									"",
									"        transactions.forEach((tx, index) => {",
									"            const hasRequestedType = tx.transaction.operations.some(op =>",
									"                op.type === requestedType",
									"            );",
									"",
									"            pm.expect(hasRequestedType, `Transaction ${index} should contain ${requestedType} operation`)",
									"                .to.be.true;",
									"        });",
									"    });",
									"}"
								]
							}
						}
					]
				},
				{
					"name": "logical operators",
					"item": [
						{
							"name": "account identifier AND withdrawal (explicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// Skip - operation type filtering not implemented yet",
											"const skipTest = true;",
											"",
											"(skipTest ? pm.test.skip : pm.test)(\"All transactions meet the specified address and type conditions\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAccountIdentifier = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.account_identifier.address",
											"        );",
											"        pm.expect(hasAccountIdentifier, `Transaction at index ${index} should contain the account identifier: ${body.account}`).to.be.true;",
											"",
											"        // Check if any operation matches the specified type",
											"        const hasType = tx.transaction.operations.some(op => ",
											"            op.type === body.type",
											"        );",
											"        pm.expect(hasType, `Transaction at index ${index} should contain the operation ${body.type}`).to.be.true;",
											"    });",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"and\",\n    \"account_identifier\": {\n        \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\"\n    },\n    \"type\": \"withdrawal\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "account identifier AND invalid (explicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"pm.test(\"All transactions meet the specified address and type conditions\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAccountIdentifier = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.account_identifier.address",
											"        );",
											"        pm.expect(hasAccountIdentifier, `Transaction at index ${index} should contain the account identifier: ${body.account}`).to.be.true;",
											"",
											"        // Check if any operation matches the specified status",
											"        const hasStatus = tx.transaction.operations.some(op => ",
											"            op.status === body.status",
											"        );",
											"        pm.expect(hasStatus, `Transaction at index ${index} should contain the operation ${body.status}`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"and\",\n    \"account_identifier\": {\n        \"address\": \"addr_test1vz8dlkd8zg4rxzs26fq95fheupph8mmgpf78rh3c5nyalsq5rgkvr\"\n    },\n    \"status\": \"invalid\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "account identifier OR stakeDelegation (explicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// Skip - operation type filtering not implemented yet",
											"const skipTest = true;",
											"",
											"(skipTest ? pm.test.skip : pm.test)(\"All transactions meet the specified address or type conditions\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAccountIdentifier = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.account_identifier.address",
											"        );",
											"",
											"        // Check if any operation matches the specified type",
											"        const hasType = tx.transaction.operations.some(op => ",
											"            op.type === body.type",
											"        );",
											"",
											"        pm.expect(hasAccountIdentifier || hasType, `Transaction at index ${index} should contain the account identifier: ${body.account_identifier.address} or the operation ${body.type}`).to.be.true;",
											"    });",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"or\",\n    \"account_identifier\": {\n        \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\"\n    },\n    \"type\": \"stakeDelegation\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "account identifier OR invalid (explicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"pm.test(\"All transactions meet the specified address and type conditions with OR logic\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAccountIdentifier = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.account_identifier.address",
											"        );",
											"",
											"        // Check if any operation matches the specified status",
											"        const hasStatus = tx.transaction.operations.some(op => ",
											"            op.status === body.status",
											"        );",
											"",
											"        pm.expect(hasAccountIdentifier || hasStatus, `Transaction at index ${index} should contain the account identifier: ${body.account_identifier.address} or operation status: ${body.status}`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"or\",\n    \"account_identifier\": {\n        \"address\": \"addr_test1vz8dlkd8zg4rxzs26fq95fheupph8mmgpf78rh3c5nyalsq5rgkvr\"\n    },\n    \"status\": \"invalid\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "address AND withdrawal (explicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"// Skip - operation type filtering not implemented yet",
											"const skipTest = true;",
											"",
											"(skipTest ? pm.test.skip : pm.test)(\"All transactions meet the specified address and type conditions\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAddress = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.address",
											"        );",
											"        pm.expect(hasAddress, `Transaction at index ${index} should contain the address: ${body.address}`).to.be.true;",
											"",
											"        // Check if any operation matches the specified type",
											"        const hasType = tx.transaction.operations.some(op => ",
											"            op.type === body.type",
											"        );",
											"        pm.expect(hasType, `Transaction at index ${index} should contain the operation ${body.type}`).to.be.true;",
											"    });",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"and\",\n    \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\",\n    \"type\": \"withdrawal\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "address AND invalid (explicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"pm.test(\"All transactions meet the specified address and type conditions\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAddress = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.address",
											"        );",
											"        pm.expect(hasAddress, `Transaction at index ${index} should contain the address: ${body.address}`).to.be.true;",
											"",
											"        // Check if any operation matches the specified type",
											"        const hasStatus = tx.transaction.operations.some(op => ",
											"            op.status === body.status",
											"        );",
											"        pm.expect(hasStatus, `Transaction at index ${index} should contain some ${body.status} operation`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"and\",\n    \"address\": \"addr_test1vz8dlkd8zg4rxzs26fq95fheupph8mmgpf78rh3c5nyalsq5rgkvr\",\n    \"status\": \"invalid\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "account identifier AND withdrawal (implicit)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const responseJson = pm.response.json();",
											"const transactions = responseJson.transactions || [];",
											"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
											"",
											"pm.test(\"All transactions meet the specified address and type conditions\", () => {",
											"    transactions.forEach((tx, index) => {",
											"        // Check if any operation has the specified address",
											"        const hasAccountIdentifier = tx.transaction.operations.some(op => ",
											"            op.account && op.account.address === body.account_identifier.address",
											"        );",
											"        pm.expect(hasAccountIdentifier, `Transaction at index ${index} should contain the account identifier: ${body.account}`).to.be.true;",
											"",
											"        // Check if any operation matches the specified type",
											"        const hasType = tx.transaction.operations.some(op => ",
											"            op.type === body.type",
											"        );",
											"        pm.expect(hasType, `Transaction at index ${index} should contain the operation ${body.type}`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    //\"operator\": \"and\",\n    \"account_identifier\": {\n        \"address\": \"addr_test1qrtdh7587yz5m2w504sjhqnrfml5fpcuxu24fj8xwvk48artcrahhulmvvsnmwqk2k3nmrz20sw8uj7htlpnlutk0p9sjfnd3n\"\n    },\n    \"type\": \"withdrawal\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "(-) invalid operator",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Invalid operator returns specific error\", () => {",
											"    const res = pm.response.json();",
											"    ",
											"    pm.expect(pm.response.code, \"Should return error status code\")",
											"        .to.be.gte(400);",
											"    ",
											"    pm.expect(res.code, \"Should have specific error code\")",
											"        .to.eql(5000);",
											"    ",
											"    pm.expect(res.message, \"Should have meaningful error message\")",
											"        .to.include(\"An error occurred\");",
											"    ",
											"    pm.expect(res.retriable, \"Should indicate as not retriable\")",
											"        .to.be.a(\"boolean\").and.to.be.false;",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"operator\": \"xor\",\n    \"type\": \"withdrawal\",\n    \"status\": \"success\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					],
					"description": "Ensures that combining multiple filters with AND/OR behaves as expected and doesnâ€™t produce incorrect matches.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"const res = pm.response.json();",
									"const transactions = res.transactions || [];",
									"const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"if (pm.response.code === 200 && transactions.length > 0) {",
									"    if (body.operator === \"and\") {",
									"        pm.test(\"ðŸ“ operator | Operator validation with filter combinations (AND)\", () => {",
									"            // For AND: all transactions should satisfy all conditions",
									"            console.log(\"AND operator: All transactions should satisfy all conditions\");",
									"        });",
									"    } else if (body.operator === \"or\") {",
									"        pm.test(\"ðŸ“ operator | Operator validation with filter combinations (OR)\", () => {",
									"            // For OR: transactions should satisfy at least one condition",
									"            console.log(\"OR operator: Transactions should satisfy at least one condition\");",
									"        });",
									"    }",
									"}"
								]
							}
						}
					]
				},
				{
					"name": "currency",
					"item": [
						{
							"name": "ada filter",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"currency\": {\n        \"symbol\": \"lovelace\",\n        \"decimals\": 6\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "ADA filter",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"currency\": {\n        \"symbol\": \"ADA\",\n        \"decimals\": 6\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "lovelace filter",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"currency\": {\n        \"symbol\": \"lovelace\",\n        \"decimals\": 6\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "asset - tTEURO by name",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"currency\": {\n        \"symbol\": \"tTEURO\",\n        \"decimals\": 6\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						},
						{
							"name": "asset - tTEURO by policyId",
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"network_identifier\": {\n        \"blockchain\": \"cardano\",\n        \"network\": \"preprod\"\n    },\n    \"currency\": {\n        \"symbol\": \"tTEURO\",\n        \"decimals\": 6,\n        \"metadata\": {\n            \"policyId\": \"e68f1cea19752d1292b4be71b7f5d2b3219a15859c028f7454f66cdf\"\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{URL}}/search/transactions",
									"host": [
										"{{URL}}"
									],
									"path": [
										"search",
										"transactions"
									]
								}
							},
							"response": []
						}
					]
				}
			],
			"description": "Main folder holding all tests for the Rosetta /search/transactions endpoint, covering filtering, pagination, and edge cases.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"const deriveErrorResponseSchema = {",
							"    \"description\": \"Instead of utilizing HTTP status codes to describe node errors (which often do not have a good analog), rich errors are returned using this object. Both the code and message fields can be individually used to correctly identify an error. Implementations MUST use unique values for both fields.\",",
							"    \"type\": \"object\",",
							"    \"required\": [",
							"      \"code\",",
							"      \"message\",",
							"      \"retriable\"",
							"    ],",
							"    \"properties\": {",
							"      \"code\": {",
							"        \"description\": \"Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.\",",
							"        \"type\": \"integer\",",
							"        \"format\": \"int32\",",
							"        \"minimum\": 0,",
							"        \"examples\": [",
							"          12",
							"        ]",
							"      },",
							"      \"message\": {",
							"        \"description\": \"Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.\",",
							"        \"type\": \"string\",",
							"        \"examples\": [",
							"          \"Invalid account format\"",
							"        ]",
							"      },",
							"      \"description\": {",
							"        \"description\": \"Description allows the implementer to optionally provide additional information about an error. In many cases, the content of this field will be a copy-and-paste from existing developer documentation. Description can ONLY be populated with generic information about a particular type of error. It MUST NOT be populated with information about a particular instantiation of an error (use `details` for this). Whereas the content of Error.Message should stay stable across releases, the content of Error.Description will likely change across releases (as implementers improve error documentation). For this reason, the content in this field is not part of any type assertion (unlike Error.Message).\",",
							"        \"type\": \"string\",",
							"        \"examples\": [",
							"          \"This error is returned when the requested AccountIdentifier is improperly formatted.\"",
							"        ]",
							"      },",
							"      \"retriable\": {",
							"        \"description\": \"An error is retriable if the same request may succeed if submitted again.\",",
							"        \"type\": \"boolean\"",
							"      },",
							"      \"details\": {",
							"        \"type\": \"object\",",
							"        \"description\": \"Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.\",",
							"        \"examples\": [",
							"          {",
							"            \"address\": \"0x1dcc4de8dec75d7aab85b567b6\",",
							"            \"error\": \"not base64\"",
							"          }",
							"        ]",
							"      }",
							"    }",
							"};",
							"const deriveResponseSchema = {",
							"    \"description\": \"SearchTransactionsResponse contains an ordered collection of BlockTransactions that match the query in SearchTransactionsRequest. These BlockTransactions are sorted from most recent block to oldest block.\",",
							"    \"type\": \"object\",",
							"    \"required\": [",
							"      \"transactions\",",
							"      \"total_count\"",
							"    ],",
							"    \"properties\": {",
							"      \"transactions\": {",
							"        \"type\": \"array\",",
							"        \"description\": \"transactions is an array of BlockTransactions sorted by most recent BlockIdentifier (meaning that transactions in recent blocks appear first). If there are many transactions for a particular search, transactions may not contain all matching transactions. It is up to the caller to paginate these transactions using the max_block field.\",",
							"        \"items\": {",
							"          \"description\": \"BlockTransaction contains a populated Transaction and the BlockIdentifier that contains it.\",",
							"          \"type\": \"object\",",
							"          \"required\": [",
							"            \"block_identifier\",",
							"            \"transaction\"",
							"          ],",
							"          \"properties\": {",
							"            \"block_identifier\": {",
							"              \"description\": \"The block_identifier uniquely identifies a block in a particular network.\",",
							"              \"type\": \"object\",",
							"              \"required\": [",
							"                \"index\",",
							"                \"hash\"",
							"              ],",
							"              \"properties\": {",
							"                \"index\": {",
							"                  \"description\": \"This is also known as the block height.\",",
							"                  \"type\": \"integer\",",
							"                  \"format\": \"int64\",",
							"                  \"examples\": [",
							"                    1123941",
							"                  ]",
							"                },",
							"                \"hash\": {",
							"                  \"type\": \"string\",",
							"                  \"description\": \"This should be normalized according to the case specified in the block_hash_case network options.\",",
							"                  \"examples\": [",
							"                    \"0x1f2cc6c5027d2f201a5453ad1119574d2aed23a392654742ac3c78783c071f85\"",
							"                  ]",
							"                }",
							"              }",
							"            },",
							"            \"transaction\": {",
							"              \"description\": \"Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.\",",
							"              \"type\": \"object\",",
							"              \"required\": [",
							"                \"transaction_identifier\",",
							"                \"operations\"",
							"              ],",
							"              \"properties\": {",
							"                \"transaction_identifier\": {",
							"                  \"description\": \"The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.\",",
							"                  \"type\": \"object\",",
							"                  \"required\": [",
							"                    \"hash\"",
							"                  ],",
							"                  \"properties\": {",
							"                    \"hash\": {",
							"                      \"description\": \"Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.  This should be normalized according to the case specified in the transaction_hash_case in network options.\",",
							"                      \"type\": \"string\",",
							"                      \"examples\": [",
							"                        \"0x2f23fd8cca835af21f3ac375bac601f97ead75f2e79143bdf71fe2c4be043e8f\"",
							"                      ]",
							"                    }",
							"                  }",
							"                },",
							"                \"operations\": {",
							"                  \"type\": \"array\",",
							"                  \"items\": {",
							"                    \"description\": \"Operations contain all balance-changing information within a transaction. They are always one-sided (only affect 1 AccountIdentifier) and can succeed or fail independently from a Transaction. Operations are used both to represent on-chain data (Data API) and to construct new transactions (Construction API), creating a standard interface for reading and writing to blockchains.\",",
							"                    \"type\": \"object\",",
							"                    \"required\": [",
							"                      \"operation_identifier\",",
							"                      \"type\"",
							"                    ],",
							"                    \"properties\": {",
							"                      \"operation_identifier\": {",
							"                        \"description\": \"The operation_identifier uniquely identifies an operation within a transaction.\",",
							"                        \"type\": \"object\",",
							"                        \"required\": [",
							"                          \"index\"",
							"                        ],",
							"                        \"properties\": {",
							"                          \"index\": {",
							"                            \"description\": \"The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.\",",
							"                            \"type\": \"integer\",",
							"                            \"format\": \"int64\",",
							"                            \"minimum\": 0,",
							"                            \"examples\": [",
							"                              5",
							"                            ]",
							"                          },",
							"                          \"network_index\": {",
							"                            \"description\": \"Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).\",",
							"                            \"type\": \"integer\",",
							"                            \"format\": \"int64\",",
							"                            \"minimum\": 0,",
							"                            \"examples\": [",
							"                              0",
							"                            ]",
							"                          }",
							"                        }",
							"                      },",
							"                      \"related_operations\": {",
							"                        \"description\": \"Restrict referenced related_operations to identifier indices < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.\",",
							"                        \"type\": \"array\",",
							"                        \"items\": {",
							"                          \"description\": \"The operation_identifier uniquely identifies an operation within a transaction.\",",
							"                          \"type\": \"object\",",
							"                          \"required\": [",
							"                            \"index\"",
							"                          ],",
							"                          \"properties\": {",
							"                            \"index\": {",
							"                              \"description\": \"The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.\",",
							"                              \"type\": \"integer\",",
							"                              \"format\": \"int64\",",
							"                              \"minimum\": 0,",
							"                              \"examples\": [",
							"                                5",
							"                              ]",
							"                            },",
							"                            \"network_index\": {",
							"                              \"description\": \"Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).\",",
							"                              \"type\": \"integer\",",
							"                              \"format\": \"int64\",",
							"                              \"minimum\": 0,",
							"                              \"examples\": [",
							"                                0",
							"                              ]",
							"                            }",
							"                          }",
							"                        },",
							"                        \"examples\": [",
							"                          [",
							"                            {",
							"                              \"index\": 1",
							"                            },",
							"                            {",
							"                              \"index\": 2",
							"                            }",
							"                          ]",
							"                        ]",
							"                      },",
							"                      \"type\": {",
							"                        \"description\": \"Type is the network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all block data.\",",
							"                        \"type\": \"string\",",
							"                        \"examples\": [",
							"                          \"Transfer\"",
							"                        ]",
							"                      },",
							"                      \"status\": {",
							"                        \"description\": \"Status is the network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply (some operations are successful and some are not). Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation. On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have a populated status field (anything on-chain must have succeeded or failed). However, operations provided during transaction construction (often times called \\\"intent\\\" in the documentation) MUST NOT have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).\",",
							"                        \"type\": \"string\",",
							"                        \"examples\": [",
							"                          \"Reverted\"",
							"                        ]",
							"                      },",
							"                      \"account\": {",
							"                        \"description\": \"The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).\",",
							"                        \"type\": \"object\",",
							"                        \"required\": [",
							"                          \"address\"",
							"                        ],",
							"                        \"properties\": {",
							"                          \"address\": {",
							"                            \"description\": \"The address may be a cryptographic public key (or some encoding of it) or a provided username.\",",
							"                            \"type\": \"string\",",
							"                            \"examples\": [",
							"                              \"0x3a065000ab4183c6bf581dc1e55a605455fc6d61\"",
							"                            ]",
							"                          },",
							"                          \"sub_account\": {",
							"                            \"description\": \"An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"address\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"address\": {",
							"                                \"description\": \"The SubAccount address may be a cryptographic value or some other identifier (ex: bonded) that uniquely specifies a SubAccount.\",",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"0x6b175474e89094c44da98b954eedeac495271d0f\"",
							"                                ]",
							"                              },",
							"                              \"metadata\": {",
							"                                \"description\": \"AccountIdentifierMetadata\",",
							"                                \"type\": \"object\",",
							"                                \"properties\": {",
							"                                  \"chain_code\": {",
							"                                    \"description\": \"ChainCode \",",
							"                                    \"type\": \"string\"",
							"                                  }",
							"                                }",
							"                              }",
							"                            }",
							"                          },",
							"                          \"metadata\": {",
							"                            \"description\": \"AccountIdentifierMetadata\",",
							"                            \"type\": \"object\",",
							"                            \"properties\": {",
							"                              \"chain_code\": {",
							"                                \"description\": \"ChainCode \",",
							"                                \"type\": \"string\"",
							"                              }",
							"                            }",
							"                          }",
							"                        }",
							"                      },",
							"                      \"amount\": {",
							"                        \"description\": \"Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.\",",
							"                        \"type\": \"object\",",
							"                        \"required\": [",
							"                          \"value\",",
							"                          \"currency\"",
							"                        ],",
							"                        \"properties\": {",
							"                          \"value\": {",
							"                            \"description\": \"Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.\",",
							"                            \"type\": \"string\",",
							"                            \"examples\": [",
							"                              \"1238089899992\"",
							"                            ]",
							"                          },",
							"                          \"currency\": {",
							"                            \"description\": \"Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"symbol\",",
							"                              \"decimals\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"symbol\": {",
							"                                \"description\": \"Canonical symbol associated with a currency.\",",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"BTC\"",
							"                                ]",
							"                              },",
							"                              \"decimals\": {",
							"                                \"description\": \"Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.\",",
							"                                \"type\": \"integer\",",
							"                                \"format\": \"int32\",",
							"                                \"minimum\": 0,",
							"                                \"examples\": [",
							"                                  8",
							"                                ]",
							"                              },",
							"                              \"metadata\": {",
							"                                \"description\": \"\",",
							"                                \"type\": \"object\",",
							"                                \"properties\": {",
							"                                  \"policyId\": {",
							"                                    \"description\": \"\",",
							"                                    \"type\": \"string\"",
							"                                  }",
							"                                }",
							"                              }",
							"                            }",
							"                          },",
							"                          \"metadata\": {",
							"                            \"type\": \"object\"",
							"                          }",
							"                        }",
							"                      },",
							"                      \"coin_change\": {",
							"                        \"description\": \"CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).\",",
							"                        \"type\": \"object\",",
							"                        \"required\": [",
							"                          \"coin_identifier\",",
							"                          \"coin_action\"",
							"                        ],",
							"                        \"properties\": {",
							"                          \"coin_identifier\": {",
							"                            \"description\": \"CoinIdentifier uniquely identifies a Coin.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"identifier\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"identifier\": {",
							"                                \"description\": \"Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.\",",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"0x2f23fd8cca835af21f3ac375bac601f97ead75f2e79143bdf71fe2c4be043e8f:1\"",
							"                                ]",
							"                              }",
							"                            }",
							"                          },",
							"                          \"coin_action\": {",
							"                            \"description\": \"CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.\",",
							"                            \"type\": \"string\",",
							"                            \"enum\": [",
							"                              \"coin_created\",",
							"                              \"coin_spent\"",
							"                            ]",
							"                          }",
							"                        }",
							"                      },",
							"                      \"metadata\": {",
							"                        \"description\": \"OperationMetadata is used to provide any additional data needed for an Operation. It is important to populate this object with any data a consumer will need to fully understand an Operation.\",",
							"                        \"type\": \"object\",",
							"                        \"properties\": {",
							"                          \"withdrawalAmount\": {",
							"                            \"description\": \"WithdrawalAmount is the amount of funds withdrawn from an account. This field should only be populated if the operation is a withdrawal.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"value\",",
							"                              \"currency\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"value\": {",
							"                                \"description\": \"Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.\",",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"1238089899992\"",
							"                                ]",
							"                              },",
							"                              \"currency\": {",
							"                                \"description\": \"Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).\",",
							"                                \"type\": \"object\",",
							"                                \"required\": [",
							"                                  \"symbol\",",
							"                                  \"decimals\"",
							"                                ],",
							"                                \"properties\": {",
							"                                  \"symbol\": {",
							"                                    \"description\": \"Canonical symbol associated with a currency.\",",
							"                                    \"type\": \"string\",",
							"                                    \"examples\": [",
							"                                      \"BTC\"",
							"                                    ]",
							"                                  },",
							"                                  \"decimals\": {",
							"                                    \"description\": \"Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.\",",
							"                                    \"type\": \"integer\",",
							"                                    \"format\": \"int32\",",
							"                                    \"minimum\": 0,",
							"                                    \"examples\": [",
							"                                      8",
							"                                    ]",
							"                                  },",
							"                                  \"metadata\": {",
							"                                    \"description\": \"\",",
							"                                    \"type\": \"object\",",
							"                                    \"properties\": {",
							"                                      \"policyId\": {",
							"                                        \"description\": \"\",",
							"                                        \"type\": \"string\"",
							"                                      }",
							"                                    }",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"metadata\": {",
							"                                \"type\": \"object\"",
							"                              }",
							"                            }",
							"                          },",
							"                          \"depositAmount\": {",
							"                            \"description\": \"DepositAmount is the amount of funds deposited into an account. This field should only be populated if the operation is a deposit.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"value\",",
							"                              \"currency\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"value\": {",
							"                                \"description\": \"Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.\",",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"1238089899992\"",
							"                                ]",
							"                              },",
							"                              \"currency\": {",
							"                                \"description\": \"Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).\",",
							"                                \"type\": \"object\",",
							"                                \"required\": [",
							"                                  \"symbol\",",
							"                                  \"decimals\"",
							"                                ],",
							"                                \"properties\": {",
							"                                  \"symbol\": {",
							"                                    \"description\": \"Canonical symbol associated with a currency.\",",
							"                                    \"type\": \"string\",",
							"                                    \"examples\": [",
							"                                      \"BTC\"",
							"                                    ]",
							"                                  },",
							"                                  \"decimals\": {",
							"                                    \"description\": \"Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.\",",
							"                                    \"type\": \"integer\",",
							"                                    \"format\": \"int32\",",
							"                                    \"minimum\": 0,",
							"                                    \"examples\": [",
							"                                      8",
							"                                    ]",
							"                                  },",
							"                                  \"metadata\": {",
							"                                    \"description\": \"\",",
							"                                    \"type\": \"object\",",
							"                                    \"properties\": {",
							"                                      \"policyId\": {",
							"                                        \"description\": \"\",",
							"                                        \"type\": \"string\"",
							"                                      }",
							"                                    }",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"metadata\": {",
							"                                \"type\": \"object\"",
							"                              }",
							"                            }",
							"                          },",
							"                          \"refundAmount\": {",
							"                            \"description\": \"RefundAmount is the amount of funds refunded to an account. This field should only be populated if the operation is a refund.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"value\",",
							"                              \"currency\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"value\": {",
							"                                \"description\": \"Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.\",",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"1238089899992\"",
							"                                ]",
							"                              },",
							"                              \"currency\": {",
							"                                \"description\": \"Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).\",",
							"                                \"type\": \"object\",",
							"                                \"required\": [",
							"                                  \"symbol\",",
							"                                  \"decimals\"",
							"                                ],",
							"                                \"properties\": {",
							"                                  \"symbol\": {",
							"                                    \"description\": \"Canonical symbol associated with a currency.\",",
							"                                    \"type\": \"string\",",
							"                                    \"examples\": [",
							"                                      \"BTC\"",
							"                                    ]",
							"                                  },",
							"                                  \"decimals\": {",
							"                                    \"description\": \"Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.\",",
							"                                    \"type\": \"integer\",",
							"                                    \"format\": \"int32\",",
							"                                    \"minimum\": 0,",
							"                                    \"examples\": [",
							"                                      8",
							"                                    ]",
							"                                  },",
							"                                  \"metadata\": {",
							"                                    \"description\": \"\",",
							"                                    \"type\": \"object\",",
							"                                    \"properties\": {",
							"                                      \"policyId\": {",
							"                                        \"description\": \"\",",
							"                                        \"type\": \"string\"",
							"                                      }",
							"                                    }",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"metadata\": {",
							"                                \"type\": \"object\"",
							"                              }",
							"                            }",
							"                          },",
							"                          \"staking_credential\": {",
							"                            \"description\": \"PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"hex_bytes\",",
							"                              \"curve_type\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"hex_bytes\": {",
							"                                \"type\": \"string\",",
							"                                \"description\": \"Hex-encoded public key bytes in the format specified by the CurveType.\"",
							"                              },",
							"                              \"curve_type\": {",
							"                                \"description\": \"CurveType is the type of cryptographic curve associated with a PublicKey. * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation)) * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf) * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys) * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)\",",
							"                                \"type\": \"string\",",
							"                                \"enum\": [",
							"                                  \"secp256k1\",",
							"                                  \"secp256k1_bip340\",",
							"                                  \"secp256r1\",",
							"                                  \"edwards25519\",",
							"                                  \"tweedle\",",
							"                                  \"pallas\"",
							"                                ]",
							"                              }",
							"                            }",
							"                          },",
							"                          \"pool_key_hash\": {",
							"                            \"description\": \"Pool key as hex bytes.\",",
							"                            \"type\": \"string\"",
							"                          },",
							"                          \"drep\": {",
							"                            \"description\": \"DRep\",",
							"                            \"type\": \"object\",",
							"                            \"properties\": {",
							"                              \"id\": {",
							"                                \"description\": \"DRepId\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"type\": {",
							"                                \"description\": \"DRepType\",",
							"                                \"type\": \"string\",",
							"                                \"enum\": [",
							"                                  \"key_hash\",",
							"                                  \"script_hash\",",
							"                                  \"no_confidence\",",
							"                                  \"abstain\"",
							"                                ]",
							"                              }",
							"                            }",
							"                          },",
							"                          \"epoch\": {",
							"                            \"description\": \"Epoch\",",
							"                            \"type\": \"integer\"",
							"                          },",
							"                          \"tokenBundle\": {",
							"                            \"description\": \"TokenBundle\",",
							"                            \"type\": \"array\",",
							"                            \"items\": {",
							"                              \"description\": \"TokenBundleItem\",",
							"                              \"type\": \"object\",",
							"                              \"properties\": {",
							"                                \"policyId\": {",
							"                                  \"description\": \"PolicyId\",",
							"                                  \"type\": \"string\"",
							"                                },",
							"                                \"tokens\": {",
							"                                  \"description\": \"Tokens\",",
							"                                  \"type\": \"array\",",
							"                                  \"items\": {",
							"                                    \"description\": \"Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.\",",
							"                                    \"type\": \"object\",",
							"                                    \"required\": [",
							"                                      \"value\",",
							"                                      \"currency\"",
							"                                    ],",
							"                                    \"properties\": {",
							"                                      \"value\": {",
							"                                        \"description\": \"Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.\",",
							"                                        \"type\": \"string\",",
							"                                        \"examples\": [",
							"                                          \"1238089899992\"",
							"                                        ]",
							"                                      },",
							"                                      \"currency\": {",
							"                                        \"description\": \"Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).\",",
							"                                        \"type\": \"object\",",
							"                                        \"required\": [",
							"                                          \"symbol\",",
							"                                          \"decimals\"",
							"                                        ],",
							"                                        \"properties\": {",
							"                                          \"symbol\": {",
							"                                            \"description\": \"Canonical symbol associated with a currency.\",",
							"                                            \"type\": \"string\",",
							"                                            \"examples\": [",
							"                                              \"BTC\"",
							"                                            ]",
							"                                          },",
							"                                          \"decimals\": {",
							"                                            \"description\": \"Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.\",",
							"                                            \"type\": \"integer\",",
							"                                            \"format\": \"int32\",",
							"                                            \"minimum\": 0,",
							"                                            \"examples\": [",
							"                                              8",
							"                                            ]",
							"                                          },",
							"                                          \"metadata\": {",
							"                                            \"description\": \"\",",
							"                                            \"type\": \"object\",",
							"                                            \"properties\": {",
							"                                              \"policyId\": {",
							"                                                \"description\": \"\",",
							"                                                \"type\": \"string\"",
							"                                              }",
							"                                            }",
							"                                          }",
							"                                        }",
							"                                      },",
							"                                      \"metadata\": {",
							"                                        \"type\": \"object\"",
							"                                      }",
							"                                    }",
							"                                  }",
							"                                }",
							"                              }",
							"                            }",
							"                          },",
							"                          \"poolRegistrationCert\": {",
							"                            \"description\": \"PoolRegistrationCert\",",
							"                            \"type\": \"string\"",
							"                          },",
							"                          \"poolRegistrationParams\": {",
							"                            \"description\": \"PoolRegistrationParams\",",
							"                            \"type\": \"object\",",
							"                            \"properties\": {",
							"                              \"vrfKeyHash\": {",
							"                                \"description\": \"VrfKeyHash\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"rewardAddress\": {",
							"                                \"description\": \"RewardAddress\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"pledge\": {",
							"                                \"description\": \"Pledge\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"cost\": {",
							"                                \"description\": \"Cost\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"poolOwners\": {",
							"                                \"description\": \"PoolOwners\",",
							"                                \"type\": \"array\",",
							"                                \"items\": {",
							"                                  \"type\": \"string\"",
							"                                }",
							"                              },",
							"                              \"relays\": {",
							"                                \"description\": \"Relays\",",
							"                                \"type\": \"array\",",
							"                                \"items\": {",
							"                                  \"description\": \"Relay\",",
							"                                  \"type\": \"object\",",
							"                                  \"properties\": {",
							"                                    \"ipv4\": {",
							"                                      \"description\": \"Ipv4\",",
							"                                      \"type\": \"string\"",
							"                                    },",
							"                                    \"ipv6\": {",
							"                                      \"description\": \"Ipv6\",",
							"                                      \"type\": \"string\"",
							"                                    },",
							"                                    \"dnsName\": {",
							"                                      \"description\": \"DnsName\",",
							"                                      \"type\": \"string\"",
							"                                    },",
							"                                    \"port\": {",
							"                                      \"description\": \"Port\",",
							"                                      \"type\": \"integer\"",
							"                                    },",
							"                                    \"type\": {",
							"                                      \"description\": \"Type\",",
							"                                      \"type\": \"string\"",
							"                                    }",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"margin\": {",
							"                                \"description\": \"Margin\",",
							"                                \"type\": \"object\",",
							"                                \"properties\": {",
							"                                  \"numerator\": {",
							"                                    \"description\": \"Numerator\",",
							"                                    \"type\": \"string\"",
							"                                  },",
							"                                  \"denominator\": {",
							"                                    \"description\": \"Denominator\",",
							"                                    \"type\": \"string\"",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"marginPercentage\": {",
							"                                \"description\": \"MarginPercentage\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"poolMetadata\": {",
							"                                \"description\": \"PoolMetadata\",",
							"                                \"type\": \"object\",",
							"                                \"properties\": {",
							"                                  \"url\": {",
							"                                    \"description\": \"url\",",
							"                                    \"type\": \"string\"",
							"                                  },",
							"                                  \"hash\": {",
							"                                    \"description\": \"hash\",",
							"                                    \"type\": \"string\"",
							"                                  }",
							"                                }",
							"                              }",
							"                            }",
							"                          },",
							"                          \"voteRegistrationMetadata\": {",
							"                            \"description\": \"VoteRegistrationMetadata\",",
							"                            \"type\": \"object\",",
							"                            \"properties\": {",
							"                              \"stakeKey\": {",
							"                                \"description\": \"VotePublicKey\",",
							"                                \"type\": \"object\",",
							"                                \"required\": [",
							"                                  \"hex_bytes\",",
							"                                  \"curve_type\"",
							"                                ],",
							"                                \"properties\": {",
							"                                  \"hex_bytes\": {",
							"                                    \"type\": \"string\",",
							"                                    \"description\": \"Hex-encoded public key bytes in the format specified by the CurveType.\"",
							"                                  },",
							"                                  \"curve_type\": {",
							"                                    \"description\": \"CurveType is the type of cryptographic curve associated with a PublicKey. * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation)) * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf) * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys) * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)\",",
							"                                    \"type\": \"string\",",
							"                                    \"enum\": [",
							"                                      \"secp256k1\",",
							"                                      \"secp256k1_bip340\",",
							"                                      \"secp256r1\",",
							"                                      \"edwards25519\",",
							"                                      \"tweedle\",",
							"                                      \"pallas\"",
							"                                    ]",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"votingkey\": {",
							"                                \"description\": \"votingkey\",",
							"                                \"type\": \"object\",",
							"                                \"required\": [",
							"                                  \"hex_bytes\",",
							"                                  \"curve_type\"",
							"                                ],",
							"                                \"properties\": {",
							"                                  \"hex_bytes\": {",
							"                                    \"type\": \"string\",",
							"                                    \"description\": \"Hex-encoded public key bytes in the format specified by the CurveType.\"",
							"                                  },",
							"                                  \"curve_type\": {",
							"                                    \"description\": \"CurveType is the type of cryptographic curve associated with a PublicKey. * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation)) * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf) * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys) * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)\",",
							"                                    \"type\": \"string\",",
							"                                    \"enum\": [",
							"                                      \"secp256k1\",",
							"                                      \"secp256k1_bip340\",",
							"                                      \"secp256r1\",",
							"                                      \"edwards25519\",",
							"                                      \"tweedle\",",
							"                                      \"pallas\"",
							"                                    ]",
							"                                  }",
							"                                }",
							"                              },",
							"                              \"rewardAddress\": {",
							"                                \"description\": \"rewardAddress\",",
							"                                \"type\": \"string\"",
							"                              },",
							"                              \"votingNonce\": {",
							"                                \"description\": \"votingNonce\",",
							"                                \"type\": \"integer\"",
							"                              },",
							"                              \"votingSignature\": {",
							"                                \"description\": \"votingSignature\",",
							"                                \"type\": \"string\"",
							"                              }",
							"                            }",
							"                          }",
							"                        }",
							"                      }",
							"                    }",
							"                  }",
							"                },",
							"                \"related_transactions\": {",
							"                  \"type\": \"array\",",
							"                  \"items\": {",
							"                    \"description\": \"The related_transaction allows implementations to link together multiple transactions. An unpopulated network identifier indicates that the related transaction is on the same network.\",",
							"                    \"type\": \"object\",",
							"                    \"required\": [",
							"                      \"transaction_identifier\",",
							"                      \"direction\"",
							"                    ],",
							"                    \"properties\": {",
							"                      \"network_identifier\": {",
							"                        \"description\": \"The network_identifier specifies which network a particular object is associated with.\",",
							"                        \"type\": \"object\",",
							"                        \"required\": [",
							"                          \"blockchain\",",
							"                          \"network\"",
							"                        ],",
							"                        \"properties\": {",
							"                          \"blockchain\": {",
							"                            \"type\": \"string\",",
							"                            \"examples\": [",
							"                              \"bitcoin\"",
							"                            ]",
							"                          },",
							"                          \"network\": {",
							"                            \"description\": \"If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.\",",
							"                            \"type\": \"string\",",
							"                            \"examples\": [",
							"                              \"mainnet\"",
							"                            ]",
							"                          },",
							"                          \"sub_network_identifier\": {",
							"                            \"description\": \"In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.\",",
							"                            \"type\": \"object\",",
							"                            \"required\": [",
							"                              \"network\"",
							"                            ],",
							"                            \"properties\": {",
							"                              \"network\": {",
							"                                \"type\": \"string\",",
							"                                \"examples\": [",
							"                                  \"shard 1\"",
							"                                ]",
							"                              },",
							"                              \"metadata\": {",
							"                                \"type\": \"object\",",
							"                                \"examples\": [",
							"                                  {",
							"                                    \"producer\": \"0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5\"",
							"                                  }",
							"                                ]",
							"                              }",
							"                            }",
							"                          }",
							"                        }",
							"                      },",
							"                      \"transaction_identifier\": {",
							"                        \"description\": \"The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.\",",
							"                        \"type\": \"object\",",
							"                        \"required\": [",
							"                          \"hash\"",
							"                        ],",
							"                        \"properties\": {",
							"                          \"hash\": {",
							"                            \"description\": \"Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.  This should be normalized according to the case specified in the transaction_hash_case in network options.\",",
							"                            \"type\": \"string\",",
							"                            \"examples\": [",
							"                              \"0x2f23fd8cca835af21f3ac375bac601f97ead75f2e79143bdf71fe2c4be043e8f\"",
							"                            ]",
							"                          }",
							"                        }",
							"                      },",
							"                      \"direction\": {",
							"                        \"description\": \"Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if a transaction relation is from child to parent or the reverse.\",",
							"                        \"type\": \"string\",",
							"                        \"enum\": [",
							"                          \"forward\",",
							"                          \"backward\"",
							"                        ]",
							"                      }",
							"                    }",
							"                  }",
							"                },",
							"                \"metadata\": {",
							"                  \"description\": \"Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.\",",
							"                  \"type\": \"object\",",
							"                  \"properties\": {",
							"                    \"size\": {",
							"                      \"description\": \"Size is the size of the transaction in bytes.\",",
							"                      \"type\": \"integer\",",
							"                      \"format\": \"int64\"",
							"                    },",
							"                    \"scriptSize\": {",
							"                      \"description\": \"ScriptSize is the size of the transaction script in bytes.\",",
							"                      \"type\": \"integer\",",
							"                      \"format\": \"int64\"",
							"                    }",
							"                  },",
							"                  \"examples\": [",
							"                    {",
							"                      \"size\": 12378,",
							"                      \"lockTime\": 1582272577",
							"                    }",
							"                  ]",
							"                }",
							"              }",
							"            }",
							"          }",
							"        }",
							"      },",
							"      \"total_count\": {",
							"        \"description\": \"total_count is the number of results for a given search. Callers typically use this value to concurrently fetch results by offset or to display a virtual page number associated with results.\",",
							"        \"type\": \"integer\",",
							"        \"format\": \"int64\",",
							"        \"minimum\": 0,",
							"        \"examples\": [",
							"          5",
							"        ]",
							"      },",
							"      \"next_offset\": {",
							"        \"description\": \"next_offset is the next offset to use when paginating through transaction results. If this field is not populated, there are no more transactions to query.\",",
							"        \"type\": \"integer\",",
							"        \"format\": \"int64\",",
							"        \"minimum\": 0,",
							"        \"examples\": [",
							"          5",
							"        ]",
							"      }",
							"    }",
							"};",
							"",
							"/**",
							" * Recursively strips every `format` key from a JSON-Schema object.",
							" * Returns a deep-cloned schema with no side effects on the original.",
							" */",
							"function stripFormats(schema) {",
							"    if (Array.isArray(schema)) {",
							"        return schema.map(stripFormats);",
							"    }",
							"    if (schema && typeof schema === 'object') {",
							"        const copy = {};",
							"        for (const key in schema) {",
							"            if (key === 'format') continue;          // â† drop the offending field",
							"            copy[key] = stripFormats(schema[key]);   // recurse",
							"        }",
							"        return copy;",
							"    }",
							"    return schema; // primitives",
							"}",
							"",
							"/* --- usage -------------------------------------------------------------- */",
							"const rawSchema = deriveResponseSchema;           // the schema you got automatically",
							"const schemaNoFormats = stripFormats(rawSchema);        // cleaned clone",
							"",
							"const res = pm.response.json();",
							"const transactions = res.transactions || [];",
							"const defaultPageLimit = 100;",
							"",
							"// --- General Validations for all /search/transactions endpoints ---",
							"if (pm.response.code == 200){",
							"    // 1. Schema validation",
							"    pm.test(\"ðŸ“ /search/transactions | Successful response schema is valid\", () => {",
							"        pm.response.to.have.jsonSchema(stripFormats(deriveResponseSchema));",
							"    });",
							"",
							"",
							"    // Transaction list length respects limit",
							"    if (res.total_count > 0) {",
							"        const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
							"        const currentLimit = body.limit || defaultPageLimit;",
							"",
							"        pm.test(\"ðŸ“ /search/transactions | Transaction list length respects limit of \" + currentLimit, () => {",
							"            pm.expect(transactions.length).and.to.be.lte(currentLimit);",
							"        });",
							"    };",
							"",
							"",
							"  ",
							"    if (transactions.length > 1) {",
							"        // total_count â‰¥ returned items",
							"        pm.test(\"ðŸ“ /search/transactions | Total transaction count â‰¥ returned items \", () => {",
							"            pm.expect(res.total_count, \"`total_count` must be â‰¥ #returned\")",
							"                .and.at.least(transactions.length);",
							"        });",
							"",
							"        // Sorting validation (if transactions present)",
							"        pm.test(\"ðŸ“ /search/transactions | Transactions sorted by block index (desc)\", () => {",
							"            const indexes = transactions.map(t => t.block_identifier.index);",
							"            const sorted = [...indexes].sort((a, b) => b - a);",
							"",
							"            pm.expect(indexes, \"newest-to-oldest order\")",
							"                .to.deep.equal(sorted);",
							"        });",
							"    };",
							"",
							"    // next_offset logic if total_count > 1 and successful response",
							"    if (res.total_count >= 1) {",
							"        pm.test(\"ðŸ“ /search/transactions | Response includes next_offset only if it has multiple pages\", () => {",
							"            const body = pm.request.body.raw ? JSON.parse(pm.request.body.raw) : {};",
							"            const currentOffset = body.offset || 0;",
							"            ",
							"            if (res.total_count > currentOffset + transactions.length) {",
							"                pm.expect(res.next_offset, \"next_offset points to next page\")",
							"                    .to.eql(currentOffset + transactions.length);",
							"            } else {",
							"                pm.expect(res, \"Response has unexpected property\").to.not.have.property(\"next_offset\");",
							"            }",
							"        });",
							"    };",
							"} else {",
							"    // Basic schema validation",
							"    pm.test(\"ðŸ“ /search/transactions | Error Response schema is valid\", () => {",
							"        pm.response.to.have.jsonSchema(stripFormats(deriveErrorResponseSchema));",
							"    });",
							"}",
							"",
							"/* ------------------ --------------------- */",
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	]
}